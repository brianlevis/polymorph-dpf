import utilities.tools as tools
import time


class Simulator:
    """
    A class which simulates an auction, given some strategy and data-set. Since
    Strategy objects are mutable, an instance of this class can only simulate
    at most one auction.
    """
    def __init__(self, strategy):
        """
        :param strategy: (Strategy) a strategy object with get_reserve and
            update methods
        """
        self.steps = 0
        self.bidders = []
        self.revenues = []
        self.reserve_prices = []
        self.reserve_times = []
        self.update_times = []
        self.strategy = strategy

    @classmethod
    def auto_file_runs(cls, test, file_names):
        """
        :param test: (Strategy) strategy object to test
        :param file_names: [str] file names of test data
        :return: (Simulator) the result of running the auction
        """
        simulator = cls(test)
        data_stream = tools.get_files_stream(file_names)
        simulator.run_auction_series(data_stream)
        return simulator

    @classmethod
    def auto_file_run(cls, test, filename):
        """
        :param test: (Strategy) strategy object to test
        :param filename: (str) filename of test data
        :return: (Simulator) the result of running the auction
        """
        simulator = cls(test)
        data_stream = tools.get_file_stream(filename)
        simulator.run_auction_series(data_stream)
        return simulator

    def run_auction_series(self, data_stream):
        """
        :param data_stream: (iter) stream yielding data for individual auctions
        :return: (None) for each item: requests a reserve price from the
            strategy, computes the result of the auction, and updates strategy
            with the outcome
        """
        for auction_data in data_stream:
            bid_prices = tools.get_bid_prices(auction_data)
            # Get reserve
            start = time.perf_counter()
            reserve_price = self.strategy.get_reserve(auction_data)
            end = time.perf_counter()
            self.reserve_times.append(end - start)
            # Run auction
            self.run_auction(bid_prices, reserve_price)
            # Update
            start = time.perf_counter()
            self.strategy.update(auction_data, bid_prices, reserve_price)
            end = time.perf_counter()
            self.update_times.append(end - start)

    def run_auction(self, bid_prices, reserve_price):
        """
        :param bid_prices: [float] bids placed in decreasing sorted order
        :param reserve_price: (float) the reserve price of the auction
        :return: (None) runs one auction
        """
        sales_price = self._get_sales_price(bid_prices, reserve_price)
        self.steps += 1
        self.bidders.append(len(bid_prices))
        self.reserve_prices.append(reserve_price)
        self.revenues.append(sales_price)

    @staticmethod
    def _get_sales_price(bid_prices, reserve_price):
        """
        :param bid_prices: [float] bids placed in decreasing sorted order
        :param reserve_price: (float) the reserve price of the auction
        :return: (float) the revenue generated by the sale, or 0
        """
        if not bid_prices or reserve_price > bid_prices[0]:
            return 0
        if len(bid_prices) == 1:
            return bid_prices[0]
        return max(bid_prices[1], reserve_price)


class Strategy:
    """
    Interface for strategy implementations. The auction will request a price
    floor at the beginning of each round, which must be a non-negative float.
    At the end of every round, the auction will call the update method with
    all the auction information, list of bid prices sorted in decreasing order
    and the price floor just set.
    """
    def get_reserve(self, auction_info):
        raise NotImplementedError()

    def update(self, auction_info, bid_prices, previous):
        raise NotImplementedError()
